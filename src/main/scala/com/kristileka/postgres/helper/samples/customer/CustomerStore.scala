package com.kristileka.postgres.helper.samples.customer

import com.kristileka.postgres.helper.samples.ERROR_CASES.DEFAULT_ERROR
import com.kristileka.postgres.helper.store.StoreEnvironment
import com.kristileka.postgres.helper.store.postgres.PostgresStore

import java.util.UUID
import javax.inject.Inject
import scala.concurrent.{ ExecutionContext, Future }

/**
  * A A Sample of the CustomerStore that runs as first wrapper that prepares
  * the data and uses a business layer of the data.
  * @param storeEnvironment The StoreEnvironment that is needed to created the deepStore
  *                         which is linked to the postgres Store.
  */
case class CustomerStore @Inject()(storeEnvironment: StoreEnvironment) {
  private lazy val store = DeepCustomerStore(
    storeEnvironment
      .getPostgresStore[Customer]("customer")
      .asInstanceOf[PostgresStore[Customer]]
  )

  /**
    * A Register Function that is used create a new instance of a customer if possible
    * @param customer The Customer Object, could be a DTO transferred here..
    * @param executionContext The implicit ExecutionContext
    * @return A future monad with Either A string Error or the created UUID for the object
    */
  def register(customer: Customer)(implicit
                                   executionContext: ExecutionContext): Future[Either[String, UUID]] =
    store.insert(customer).map {
      case Left(value) => Left(value)
      case Right(value) =>
        if (value) Right(customer.id) else Left(DEFAULT_ERROR)
    }

  /**
    * A Update function that is used to update the customer
    * @param id THe UUID of the customer to update
    * @param customer The Customer object with the changes
    * @param executionContext The implicit ExecutionContext
    * @return A Future monad that holds the Error generated by the DB, or a boolean representing
    *         the status of the execution
    */
  def update(id: UUID, customer: Customer)(implicit
                                           executionContext: ExecutionContext,
  ): Future[Either[String, Boolean]] = store.update(id: UUID, customer)

  /**
    *  A function to find a customer by Uuid.
    * @param uuid The UUID of the customer to update
    * @param executionContext The implicit ExecutionContext
    * @return A Future Monad of Either Error if error occurred, or an Option[Customer]
    *         which either holds the customer or a None if not found
    */
  def findById(uuid: UUID)(implicit
                           executionContext: ExecutionContext): Future[Either[String, Option[Customer]]] =
    store.findById(uuid)

  /**
    * A Function to find all Customers
    * @param executionContext The implicit ExecutionContext
    * @return A Future Monad of EIther the Erorr if error occurred, or a Sequence of the Customers
    *         that were found.
    */
  def findAll()(
      implicit
      executionContext: ExecutionContext
  ): Future[Either[String, Seq[Customer]]] = store.findAll()

  /**
    *
    * @param email                The email of the customer to find
    * @param executionContext     The implicit ExecutionContext
    * @return A Future Monad of Either Error if error occurred, or an Option[Customer]
    *         which either holds the customer or a None if not found
    */
  def getCustomerByEmail(email: String)(implicit
                                        executionContext: ExecutionContext): Future[Either[String, Option[Customer]]] =
    store.findWhere(Map("email" -> email)).map(_.map(_.headOption))

}
